"""
Tarihsel Veri Tabanlƒ± Hava Durumu Tahmin Sistemi

Bu mod√ºl, ger√ßek tarihsel hava durumu verilerini kullanarak
g√ºn bazƒ±nda olasƒ±lƒ±k hesaplamalarƒ± yapar ve ML modellerini eƒüitir.

√ñzellikler:
- Ger√ßek tarihsel verilerle olasƒ±lƒ±k hesaplama
- G√ºn bazƒ±nda hava durumu tahmini
- ML modelleri i√ßin eƒüitim verisi
- Y√ºksek doƒüruluk oranƒ±
"""

from historical_weather_data import HistoricalWeatherDataCollector
from flask import Flask, request, jsonify
from flask_cors import CORS #(Cross-Origin Resource Sharing)
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
import json
import joblib
import os
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
import warnings
warnings.filterwarnings('ignore')

app = Flask(__name__)
CORS(app)

class HistoricalWeatherPredictor:
    def __init__(self):
        self.collector = HistoricalWeatherDataCollector()
        self.weather_model = None
        self.temperature_model = None
        self.scaler = StandardScaler()
        self.weather_encoder = LabelEncoder()
        
        # Model dosyalarƒ±nƒ±n yollarƒ±
        self.model_files = [
            '../models/historical_weather_model.pkl',
            '../models/historical_temperature_model.pkl',
            '../models/historical_scaler.pkl',
            '../models/historical_weather_encoder.pkl'
        ]
        
        # Modelleri y√ºkle veya eƒüit
        self.load_or_train_models()
        
        print("üå§Ô∏è Tarihsel Veri Tabanlƒ± Hava Durumu Tahmin Sistemi Ba≈ülatƒ±ldƒ±")
    
    def load_or_train_models(self):
        """ML modellerini y√ºkle veya eƒüit"""
        # Model dosyalarƒ±nƒ±n varlƒ±ƒüƒ±nƒ± kontrol et
        if all(os.path.exists(f) for f in self.model_files):
            try:
                self.weather_model = joblib.load(self.model_files[0])
                self.temperature_model = joblib.load(self.model_files[1])
                self.scaler = joblib.load(self.model_files[2])
                self.weather_encoder = joblib.load(self.model_files[3])
                print("‚úÖ Tarihsel veri modelleri y√ºklendi")
                return
            except Exception as e:
                print(f"‚ùå Model y√ºkleme hatasƒ±: {e}")
        
        print("ü§ñ Tarihsel veri modelleri eƒüitiliyor...")
        self.train_models()
    
    def train_models(self):
        """ML modellerini eƒüit"""
        try:
            # Eƒüitim verisini al
            training_data = self.collector.generate_training_data()
            
            if training_data.empty:
                print("‚ùå Eƒüitim verisi bulunamadƒ±!")
                return
            
            print(f"üìä Eƒüitim verisi: {len(training_data)} kayƒ±t")
            
            # √ñzellikleri hazƒ±rla
            features = self._prepare_features(training_data)
            
            # Hava durumu sƒ±nƒ±flandƒ±rma modeli
            X_weather = features.drop(['weather_main', 'temperature'], axis=1, errors='ignore')
            y_weather = self.weather_encoder.fit_transform(training_data['weather_main'])
            
            # Sƒ±caklƒ±k regresyon modeli
            X_temp = features.drop(['weather_main', 'temperature'], axis=1, errors='ignore')
            y_temp = training_data['temperature']
            
            # Veriyi eƒüitim ve test olarak b√∂l
            X_weather_train, X_weather_test, y_weather_train, y_weather_test = train_test_split(
                X_weather, y_weather, test_size=0.2, random_state=42
            )
            
            X_temp_train, X_temp_test, y_temp_train, y_temp_test = train_test_split(
                X_temp, y_temp, test_size=0.2, random_state=42
            )
            
            # Modelleri eƒüit
            print("üå§Ô∏è Hava durumu sƒ±nƒ±flandƒ±rma modeli eƒüitiliyor...")
            self.weather_model = RandomForestClassifier(n_estimators=100, random_state=42)
            self.weather_model.fit(X_weather_train, y_weather_train)
            
            print("üå°Ô∏è Sƒ±caklƒ±k regresyon modeli eƒüitiliyor...")
            self.temperature_model = RandomForestRegressor(n_estimators=100, random_state=42)
            self.temperature_model.fit(X_temp_train, y_temp_train)
            
            # Model performansƒ±nƒ± deƒüerlendir
            weather_accuracy = accuracy_score(y_weather_test, self.weather_model.predict(X_weather_test))
            temp_r2 = self.temperature_model.score(X_temp_test, y_temp_test)
            
            print(f"‚úÖ Hava durumu modeli doƒüruluƒüu: {weather_accuracy:.3f}")
            print(f"‚úÖ Sƒ±caklƒ±k modeli R¬≤ skoru: {temp_r2:.3f}")
            
            # Modelleri kaydet
            os.makedirs('../models', exist_ok=True)
            joblib.dump(self.weather_model, self.model_files[0])
            joblib.dump(self.temperature_model, self.model_files[1])
            joblib.dump(self.scaler, self.model_files[2])
            joblib.dump(self.weather_encoder, self.model_files[3])
            
            print("üíæ Modeller kaydedildi")
            
        except Exception as e:
            print(f"‚ùå Model eƒüitimi hatasƒ±: {e}")
    
    def _prepare_features(self, data: pd.DataFrame) -> pd.DataFrame:
        """ML modelleri i√ßin √∂zellikleri hazƒ±rla"""
        features = data.copy()
        
        # Tarih √∂zellikleri
        features['date'] = pd.to_datetime(features['date'])
        features['month'] = features['date'].dt.month
        features['day'] = features['date'].dt.day
        features['day_of_year'] = features['date'].dt.dayofyear
        features['day_of_week'] = features['date'].dt.dayofweek
        
        # Mevsim √∂zellikleri
        features['season'] = features['month'].map({
            12: 0, 1: 0, 2: 0,  # Kƒ±≈ü
            3: 1, 4: 1, 5: 1,   # ƒ∞lkbahar
            6: 2, 7: 2, 8: 2,   # Yaz
            9: 3, 10: 3, 11: 3  # Sonbahar
        })
        
        # Coƒürafi √∂zellikler
        features['latitude'] = features['latitude'].fillna(39.0)
        features['longitude'] = features['longitude'].fillna(35.0)
        
        # Eksik deƒüerleri doldur
        features['humidity'] = features['humidity'].fillna(50)
        features['wind_speed'] = features['wind_speed'].fillna(10)
        features['probability'] = features['probability'].fillna(0.5)
        features['sample_count'] = features['sample_count'].fillna(1)
        
        # Sayƒ±sal √∂zellikleri se√ß
        numeric_features = [
            'month', 'day', 'day_of_year', 'day_of_week', 'season',
            'latitude', 'longitude', 'humidity', 'wind_speed', 
            'probability', 'sample_count'
        ]
        
        return features[numeric_features + ['weather_main', 'temperature']]
    
    def predict_weather(self, city: str, date_str: str) -> Dict:
        """Belirli bir ≈üehir ve tarih i√ßin hava durumu tahmini"""
        try:
            # Tarihi parse et
            date_obj = datetime.strptime(date_str, '%Y-%m-%d')
            month = date_obj.month
            day = date_obj.day
            
            # Tarihsel olasƒ±lƒ±klarƒ± al
            historical_prob = self.collector.get_daily_weather_probability(city, month, day)
            
            # Ge√ßmi≈ü √∂rnekleri al
            historical_examples = self.collector.get_historical_examples(city, month, day, limit=5)
            
            # ML modeli i√ßin √∂zellikleri hazƒ±rla
            city_coords = self.collector.cities_data.get(city, {"lat": 39.0, "lon": 35.0})
            
            features = pd.DataFrame([{
                'month': month,
                'day': day,
                'day_of_year': date_obj.timetuple().tm_yday,
                'day_of_week': date_obj.weekday(),
                'season': (month % 12 + 3) // 3,
                'latitude': city_coords['lat'],
                'longitude': city_coords['lon'],
                'humidity': np.mean([ex['humidity'] for ex in historical_examples]) if historical_examples else 50,
                'wind_speed': np.mean([ex['wind_speed'] for ex in historical_examples]) if historical_examples else 10,
                'probability': historical_prob.get('confidence', 0.5),
                'sample_count': historical_prob.get('sample_count', 1)
            }])
            
            # ML tahminleri
            if self.weather_model is not None:
                weather_pred = self.weather_encoder.inverse_transform(
                    self.weather_model.predict(features)
                )[0]
                weather_proba = self.weather_model.predict_proba(features)[0]
                ml_confidence = max(weather_proba)
            else:
                weather_pred = historical_prob.get('most_likely', 'Unknown')
                ml_confidence = 0.5
            
            if self.temperature_model is not None:
                predicted_temp = self.temperature_model.predict(features)[0]
            else:
                predicted_temp = np.mean([ex['temperature'] for ex in historical_examples]) if historical_examples else 20
            
            # Sonu√ßlarƒ± birle≈ütir
            result = {
                "city": city,
                "date": date_str,
                "predicted_weather": weather_pred,
                "predicted_temperature": round(predicted_temp, 1),
                "historical_probabilities": historical_prob.get('weather_probabilities', {}),
                "historical_examples": historical_examples,
                "ml_confidence": ml_confidence,
                "historical_confidence": historical_prob.get('confidence', 0.0),
                "sample_count": historical_prob.get('sample_count', 0),
                "explanation": self._generate_explanation(city, month, day, historical_prob, historical_examples)
            }
            
            return result
            
        except Exception as e:
            print(f"‚ùå Hava durumu tahmin hatasƒ±: {e}")
            return self._get_fallback_prediction(city, date_str)
    
    def _generate_explanation(self, city: str, month: int, day: int, 
                            historical_prob: Dict, historical_examples: List[Dict]) -> str:
        """Tahmin i√ßin a√ßƒ±klama olu≈ütur"""
        if not historical_examples:
            return f"{city} i√ßin {month}/{day} tarihinde yeterli tarihsel veri bulunamadƒ±."
        
        # En sƒ±k g√∂r√ºlen hava durumlarƒ±
        weather_counts = {}
        for example in historical_examples:
            weather = example['weather']
            weather_counts[weather] = weather_counts.get(weather, 0) + 1
        
        most_common = max(weather_counts.items(), key=lambda x: x[1])
        
        # Sƒ±caklƒ±k ortalamasƒ±
        avg_temp = np.mean([ex['temperature'] for ex in historical_examples])
        
        explanation = f"{city} i√ßin {month}/{day} tarihinde son {len(historical_examples)} yƒ±lda "
        explanation += f"en sƒ±k {most_common[0]} hava durumu g√∂r√ºlm√º≈ü ({most_common[1]} kez). "
        explanation += f"Ortalama sƒ±caklƒ±k {avg_temp:.1f}¬∞C. "
        
        if historical_prob.get('weather_probabilities'):
            top_prob = max(historical_prob['weather_probabilities'].items(), 
                          key=lambda x: x[1]['probability'])
            explanation += f"Tarihsel olasƒ±lƒ±k hesaplamasƒ±na g√∂re %{top_prob[1]['probability']*100:.0f} "
            explanation += f"{top_prob[0]} olasƒ±lƒ±ƒüƒ± var."
        
        return explanation
    
    def _get_fallback_prediction(self, city: str, date_str: str) -> Dict:
        """Fallback tahmin"""
        return {
            "city": city,
            "date": date_str,
            "predicted_weather": "Unknown",
            "predicted_temperature": 20.0,
            "historical_probabilities": {},
            "historical_examples": [],
            "ml_confidence": 0.0,
            "historical_confidence": 0.0,
            "sample_count": 0,
            "explanation": "Yeterli veri bulunamadƒ±ƒüƒ± i√ßin tahmin yapƒ±lamadƒ±."
        }
    
    def predict_route_weather(self, cities: List[str], date_str: str) -> Dict:
        """Rota √ºzerindeki t√ºm ≈üehirler i√ßin hava durumu tahmini"""
        predictions = []
        total_confidence = 0
        
        for city in cities:
            prediction = self.predict_weather(city, date_str)
            predictions.append(prediction)
            total_confidence += prediction.get('ml_confidence', 0)
        
        avg_confidence = total_confidence / len(cities) if cities else 0
        
        return {
            "predictions": predictions,
            "route_summary": {
                "total_cities": len(cities),
                "avg_confidence": avg_confidence,
                "weather_conditions": list(set([p["predicted_weather"] for p in predictions])),
                "avg_temperature": sum([p["predicted_temperature"] for p in predictions]) / len(predictions) if predictions else 20.0
            }
        }
    
    def get_city_statistics(self, city: str) -> Dict:
        """≈ûehir i√ßin istatistiksel bilgiler"""
        return self.collector.get_city_statistics(city)

# Flask API
app = Flask(__name__)
CORS(app)  # CORS desteƒüi ekle
predictor = HistoricalWeatherPredictor()

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({
        "status": "healthy",
        "service": "Historical Weather Predictor",
        "models_loaded": predictor.weather_model is not None and predictor.temperature_model is not None,
        "cities_supported": len(predictor.collector.cities_data)
    })

@app.route('/predict', methods=['POST'])
def predict_weather():
    try:
        data = request.get_json()
        city = data.get('city')
        date = data.get('date')
        
        if not city or not date:
            return jsonify({"error": "city ve date parametreleri gerekli"}), 400
        
        prediction = predictor.predict_weather(city, date)
        return jsonify(prediction)
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/predict_route', methods=['POST'])
def predict_route():
    try:
        data = request.get_json()
        cities = data.get('cities', [])
        date = data.get('date')
        
        if not cities or not date:
            return jsonify({"error": "cities ve date parametreleri gerekli"}), 400
        
        prediction = predictor.predict_route_weather(cities, date)
        return jsonify(prediction)
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/statistics/<city>', methods=['GET'])
def get_city_statistics(city):
    try:
        stats = predictor.get_city_statistics(city)
        return jsonify(stats)
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    print("üöÄ Tarihsel Veri Tabanlƒ± Hava Durumu Tahmin Servisi Ba≈ülatƒ±lƒ±yor...")
    print("üìä √ñrnek kullanƒ±m:")
    print("  POST /predict - Tek ≈üehir tahmini")
    print("  POST /predict_route - Rota tahmini")
    print("  GET /statistics/<city> - ≈ûehir istatistikleri")
    
    app.run(host='0.0.0.0', port=5002, debug=True) 